"""Wrapper around Qt libraries to make it easier to swap out backends in the future
"""
from __future__ import print_function
import os, sys, importlib, inspect
from .. import pyqtgraph as pg

# make one large namespace containing everything; pyqtgraph handles translation
# between different Qt versions
globals().update(pg.Qt.QtGui.__dict__)
globals().update(pg.Qt.QtCore.__dict__)
globals().update(pg.Qt.QtTest.__dict__)
#globals().update(importlib.import_module(pg.Qt.QT_LIB + '.QtSql').__dict__)


def importTemplate(modName):
    """Return the template class generated by a .ui file for the Qt system 
    currently in use.
    
    If the module path is relative (starts with "."), then the root package is
    inferred by inspecting the frame stack.
    
    For example::
    
        Ui_MainWindow = Qt.importTemplate('.MyTemplate')
        
        # For PyQt4, this is equivalent to
        from .MyTemplate import Ui_MainWindow
        
        # for PyQt5, this is equivalent to
        from .MyTemplate_pyqt5 import Ui_MainWindow
    """
    if pg.Qt.QT_LIB == 'PyQt5':
        modName = modName + '_pyqt5'
    
    if modName[0] == '.':
        frame = sys._getframe().f_back
        pkg = frame.f_globals['__package__']
    else:
        pkg = None
    
    mod = importlib.import_module(modName, package=pkg)

    for k,v in mod.__dict__.items():
        if k[:3] == 'Ui_' and inspect.isclass(v):
            return v
        
    raise Exception("Could not find Ui_* class in module %s" % modName)
