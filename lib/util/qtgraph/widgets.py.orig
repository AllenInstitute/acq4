from PyQt4 import QtCore, QtGui, QtOpenGL, QtSvg
from GraphicsView import qPtArr
from numpy import array, arccos, dot, pi
from numpy.linalg import norm
from vector import *


class ROI():
  def __init__(self, pos):
    self.setPen(QtGui.QPen(QtGui.QColor(255, 255, 255)))
    self.handlePen = QtGui.QPen(QtGui.QColor(150, 255, 255))
    self.handles = []
    self.state = {'pos': pos, 'scale': array([1.0, 1.0]), 'rotate': 0.0}
    self.updateTransform()
    self.handleSize = 5
    
    
    
  def addTranslateHandle(self, pos, axes=None):
    self.addHandle({'type': 't', 'pos': array(pos)})
  
  def addScaleHandle(self, pos, center, axes=None):
    info = {'type': 's', 'center': array(center), 'pos': array(pos)}
    if pos[0] == center[0]:
      info['xoff'] = True
    if pos[1] == center[1]:
      info['yoff'] = True
    self.addHandle(info)
  
  def addRotateHandle(self, pos, center):
    self.addHandle({'type': 'r', 'center': array(center), 'pos': array(pos)})
  
  def addScaleRotateHandle(self, pos, center):
    pass
  
  def addHandle(self, info):
    h = Handle(self.handleSize, typ=info['type'], pen=self.handlePen, parent=self)
    h.setZValue(10)
    h.moveBy(info['pos'][0], info['pos'][1])
    info['item'] = h
    iid = len(self.handles)
    h.mouseMoveEvent = lambda ev: self.pointMove(iid, ev)
    self.handles.append(info)
    
  
  def pointMove(self, pt, ev):
    h = self.handles[pt]
    #print qPtArr(ev.lastScenePos()), qPtArr(ev.scenePos())
    
    if h['type'] == 't':
      d = qPtArr(ev.scenePos() - ev.lastScenePos())
      self.translate(d)
      #self.moveBy(d[0], d[1])
    
    elif h['type'] == 's':
      c = h['center']
      d1 = (qPtArr(self.mapFromScene(ev.scenePos())) - c)
      d2 = (qPtArr(self.mapFromScene(ev.lastScenePos())) - c)
      if (d1 == 0.).any() or (d2 == 0).any():
        return
      d = d1 / d2
      invd = d2 / d1
      if h.has_key('xoff') and h['xoff']:
        d[0] = 1.0
      if h.has_key('yoff') and h['yoff']:
        d[1] = 1.0
      self.scale(d, c)
      #self.translate(c[0], c[1])
      #self.scale(d[0], d[1])
      #self.translate(-c[0], -c[1])
      
      #for h in self.handles:
        #h['item'].scale(invd[0], invd[1])
    
    elif h['type'] == 'r':
      c = h['center']
      d1 = qPtArr(ev.scenePos() - self.mapToScene(arrQPt(c)))
      d2 = qPtArr(ev.lastScenePos() - self.mapToScene(arrQPt(c)))
      if (d1 == 0.).any() or (d2 == 0).any():
        return
      ang = angle(d1, d2)
      if angle is None:
        return
      if ev.modifiers() & QtCore.Qt.ControlModifier:
        ang = (round((self.state['rotate'] + ang) / (pi/12.)) * (pi/12.)) - self.state['rotate']
      self.rotate(ang, c)
      #self.translate(c[0], c[1])
      #self.setTransform(self.transform().rotate(ang))
      #self.translate(-c[0], -c[1])
      
      
  def updateTransform(self):
    t = QtGui.QTransform()
    t.translate(self.state['pos'][0], self.state['pos'][1])
    t.rotateRadians(self.state['rotate'])
    t.scale(self.state['scale'][0], self.state['scale'][1])
    self.setTransform(t)
    
  def rotate(self, angle, center=None):
    if center is not None:
      c = rotate(-center * self.state['scale'], self.state['rotate']) 
      c1 = rotate(c, angle)
      self.state['pos'] += c1-c
    self.state['rotate'] += angle
    self.updateTransform()

  def scale(self, scale, center=None):
    if center is not None:
      oc = center*self.state['scale']
      self.state['pos'] += oc - (oc * scale)
    self.state['scale'] *= scale
    self.updateTransform()
    
  def translate(self, tx):
    self.state['pos'] += tx
    self.updateTransform()


class TestROI(ROI, QtGui.QGraphicsRectItem):
  def __init__(self, pos, size):
    QtGui.QGraphicsRectItem.__init__(self, pos[0], pos[1], size[0], size[1])
    ROI.__init__(self, pos)
    self.addTranslateHandle([0, 0])
    self.addTranslateHandle([size[0]/2., size[1]/2.])
    self.addScaleHandle([size[0], size[1]], [0, 0])
    self.addScaleHandle([size[0], size[1]/2.], [size[0]/2., size[1]/2.])
    self.addScaleHandle([size[0]/2., size[1]], [size[0]/2., size[1]/2.])
    self.addRotateHandle([size[0], 0], [0, 0])
    self.addRotateHandle([0, size[1]], [size[0], size[1]])



class RectROI(ROI, QtGui.QGraphicsRectItem):
  def __init__(self, pos, size, centered=False, sideScalers=False):
    QtGui.QGraphicsRectItem.__init__(self, 0, 0, size[0], size[1])
    ROI.__init__(self, pos)
    if centered:
      center = [size[0]/2., size[1]/2.]
    else:
      center = [0, 0]
      
    self.addTranslateHandle(center)
    self.addScaleHandle([size[0], size[1]], center)
    if sideScalers:
      self.addScaleHandle([size[0], size[1]/2.0], [center[0], size[1]/2.0])
      self.addScaleHandle([size[0]/2.0, size[1]], [size[0]/2.0, center[1]])



class Handle(QtGui.QGraphicsItem):
  def __init__(self, radius, typ=None, pen=QtGui.QPen(QtGui.QColor(200, 200, 220)), parent=None):
    QtGui.QGraphicsItem.__init__(self, parent)
    self.radius = radius
    self.typ = typ
    self.bounds = QtCore.QRectF(-1e-10, -1e-10, 2e-10, 2e-10)
    self.pen = pen
    if typ == 't':
      self.sides = 4
      self.startAng = pi/4
    elif typ == 's':
      self.sides = 4
      self.startAng = 0
    elif typ == 'r':
      self.sides = 12
      self.startAng = 0
    else:
      self.sides = 4
      self.startAng = pi/4
      
  
  def boundingRect(self):
    return self.bounds
    
  def paint(self, p, opt, widget):
    m = p.transform()
    mi = m.inverted()[0]
    size = mi.map(QtCore.QPointF(self.radius, self.radius)) - mi.map(QtCore.QPointF(0, 0))
    bounds = QtCore.QRectF(-size.x(), -size.y(), size.x()*2, size.y()*2)
    if bounds != self.bounds:
      self.bounds = bounds
      self.prepareGeometryChange()
    
    
    #center = m.map(self.scenePos())
    #print self.pos().x(), self.pos().y()
    #p.resetTransform()
    p.setPen(self.pen)
    ang = self.startAng
    dt = 2*pi / self.sides
    for i in range(0, self.sides):
      x1 = size.x() * cos(ang)
      y1 = size.y() * sin(ang)
      x2 = size.x() * cos(ang+dt)
      y2 = size.y() * sin(ang+dt)
      ang += dt
      p.drawLine(QtCore.QPointF(x1, y1), QtCore.QPointF(x2, y2))
    #p.setTransform(m)
    
    