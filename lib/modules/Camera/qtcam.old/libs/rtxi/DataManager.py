import threading, os, fcntl, time, re

class Locker:
  def __init__(self, lock):
    self.lock = lock
    self.lock.acquire()
  def __del__(self):
    self.lock.release()

class DataManagerFactory:
  """Class for creating and caching DataManager objects to make sure there is only one manager object per directory. ONE OBJECT IS GENERATED BY THE LIBRARY, DO NOT CREATE YOUR OWN! Use createDataManager as your starting point."""
  
  def __init__(self, password=None):
    if password != "do not copy this password":
      raise Exception("Applications should not create their own Factories, use createDataManager as a starting point.")
    self.dm = {}
    self.lock = threading.Lock()
    
  def getDM(self, dirName, create=False):
    l = Locker(self.lock)
    if not self.dm.has_key(dirName):
      self.dm['dirName'] = DataManager(self, dirName, create=create)
    dm = self.dm['dirName']
    return dm

GLOBAL_DMFACTORY = DataManagerFactory("do not copy this password")

def createDataManager(baseDir, create=False):
  global GLOBAL_DMFACTORY
  return GLOBAL_DMFACTORY.getDM(baseDir, create=create)




class DataManager:
  def __init__(self, manager, baseDir, create=False):
    self.manager = manager
    self.baseDir = baseDir
    if self.baseDir[-1] != '/':
      self.baseDir += '/'
    self.indexFile = self.baseDir+'.index'
    self.logFile = self.baseDir+'.log'
    
    self.lock = threading.RLock()
    
    if not os.path.isdir(baseDir):
      if create:
        os.mkdir(baseDir)
      else:
        raise Exception("Directory %s does not exist." % baseDir)
    
    if os.path.isfile(self.indexFile):
      self._readIndex()
    else:
      self.index = {}
      self._writeIndex()
    
  def __del__(self):
    pass
  
  def _readIndex(self, lock=True):
    l = Locker(self.lock)
    fd = open(self.indexFile)
    if lock:
      fcntl.flock(fd, fcntl.LOCK_EX)
    try:
      self.index = eval(fd.read())
    except:
      print "***************Error while reading index file %s!*******************" % self.indexFile
      raise
    fd.close()
    
  def _writeIndex(self, lock=True):
    l = Locker(self.lock)
    fd = open(self.indexFile, 'w')
    if lock:
      fcntl.flock(fd, fcntl.LOCK_EX)
    fd.write(str(self.index))
    fd.close()
  
  def logMsg(self, msg):
    """Write a message into the log for this directory."""
    l = Locker(self.lock)
    t = time.strftime('[20%y.%m.%d %H:%m:%S]')
    fd = open(self.logFile, 'a')
    fcntl.flock(fd, fcntl.LOCK_EX)
    fd.write('%s %s\n', (t, msg))
    fd.close()
  
  def mkdir(self, name, autoIndex=False, info={}):
    """Create a new subdirectory, return a new DataManager object. If autoIndex is true, add a number to the end of the dir name if it already exists."""
    l = Locker(self.lock)
    
    if autoIndex:
      fullName = name+"_000"
    else:
      fullName = name
      
    if os.path.isdir(self.baseDir+fullName):
      if autoIndex:
        files = os.listdir(self.baseDir)
        files = filter(lambda f: re.match(name + r'_\d+$', f), files)
        files.sort()
        maxVal = int(files[-1][-3:])
        fullName = name + "_%03d" % (maxVal+1)
      else:
        raise Exception("Directory %s already exists." % (self.baseDir+fullName))
      
    ndm = self.manager.getDM(self.baseDir+fullName, create=True)
    self.addFile(fullName, info)
    return ndm
  
  def getDir(self, subdir, create=False):
    l = Locker(self.lock)
    ndir = self.baseDir+subdir
    if os.path.isdir(ndir):
      return self.manager.getDM(ndir)
    else:
      if create:
        return self.createSubdir(subdir)
      else:
        raise Exception('Directory %s does not exist.' % ndir)
    
  def dirExists(self, dirName):
    return os.path.isdir(self.baseDir+dirName)
      
  def getToday(self):
    return self.getDir(time.strftime("20%y.%m.%d"), create=True)
  
  
  def ls(self):
    """Return a list of all managed files in the directory"""
    l = Locker(self.lock)
    self._readIndex()
    ls = self.index.keys()
    ls.sort(strncmp)
    return ls
  
  def fileInfo(self, file):
    """Return a dict of the meta info stored for file"""
    l = Locker(self.lock)
    self._readIndex()
    if self.index.has_key(file):
      return self.index[file]
    else:
      raise Exception("File %s is not indexed" % file)
  
  def writeFile(self, object, file, info={}):
    """Write a file to this directory using object.write(fileName), store info in the index."""
    l = Locker(self.lock)
    fn = self.baseDir+file
    fd = open(fn, 'w')
    fcntl.flock(fd, fcntl.LOCK_EX)
    object.write(fn)
    fd.close()
    
    self.setFileInfo(fileName, info)
  
  def addFile(self, file, info={}, protect=False):
    """Add a pre-existing file into the index. Overwrites any pre-existing info for the file unless protect is True"""
    l = Locker(self.lock)
    fn = self.baseDir+file
    if not (os.path.isfile(fn) or os.path.isdir(fn)):
      raise Exception("File %s does not exist." % fn)
    if protect and self.index.has_key(file):
      raise Exception("File %s is already indexed." % file)
    self.setFileInfo(file, info)
  
  def setFileInfo(self, file, info):
    l = Locker(self.lock)
    fd = open(self.indexFile, 'r')
    fcntl.flock(fd, fcntl.LOCK_EX)
    self._readIndex(lock=False)
    self.index[file] = info
    self._writeIndex(lock=False)
    fd.close()
    
  def setFileAttr(file, attr, value):
    l = Locker(self.lock)
    if not self.index.has_key('file'):
      self.setFileInfo(file, {attr: value})
    else:
      fd = open(self.indexFile, 'r')
      fcntl.flock(fd, fcntl.LOCK_EX)
      self._readIndex(lock=False)
      self.index[file][attr] = value
      self._writeIndex(lock=False)
      fd.close()
    
  def parent(self):
    pdir = re.sub(r'/[^/]+/$', '', self.baseDir)
    return self.manager.getDM(pdir)
  